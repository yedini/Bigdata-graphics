###10/8 빅데이터###

library(tidyverse)

#산점도에 통계량 표시하기

ggplot(mpg, aes(trans, cty)) +
  geom_point() +
  stat_summary(geom="point", fun.y="mean", colour="red", size=4)
#trans는 catecorical variable. 각 trans 종류마다의 평균을 그래프 위에 점으로 찍음.
#stat_summary를 할건데 표시는 point로, 구하는 값은 평균.

#median 표시하기
ggplot(mpg, aes(trans, cty)) +
  geom_point() +
  stat_summary(geom="point", fun.y="median", colour="blue", size=3)

ggplot(mpg, aes(trans, cty)) +
  geom_point() +
  geom_point(stat="summary", fun.y="mean", colour="red", size=4) 
#stat을 identity로 하지말고 summary로 바꿔라.

A <- ggplot(mpg, aes(trans, cty))+geom_point()
summary(A)
#summary를 보면 stat_identity 잡혀있음을 알 수 있음.

B <- ggplot(mpg, aes(trans, cty))+
  geom_point(stat="summary", fun.y="median", color="blue", size=3)
summary(B)
#stat_summary로 잡혀있다!

##모든 geom에 stat이 설정되어있음을 알 수 있다.

#앞뒤에 ..이 붙어있는 것 : 내부변수
# ..x.. : 각 범주의 중심 / ..count.. : 각 범주 관측수 / ..density.. : 각 범주 관측비율

ggplot(diamonds, aes(price))+geom_histogram(binwidth=500)

#count대신 density로 histogram 표현하기 -> ..density.. 사용 (default는 ..count..)
ggplot(diamonds, aes(price))+
  geom_histogram(aes(y=..density..), binwidth=500)
# -> 이렇게 하면 그림은 같지만 y의 scale이 달라진다!


ggplot(diamonds, aes(price, color=cut))+
  geom_freqpoly(binwidth=500)

ggplot(diamonds, aes(price, color=cut))+
  geom_freqpoly(binwidth=500) +
  theme(legend.position="none")

table(diamonds$cut)

Fair      Good Very Good   Premium     Ideal 
1610      4906     12082     13791     21551 
#-> 종류마다 빈도 차이가 심함 -> count보다 density로 표현하는게 더 낫다!

ggplot(diamonds, aes(price, color=cut))+
  geom_freqpoly(aes(y=..density..), binwidth=500)


#title 지정
df <- data.frame(x = 1:2, y = 1, z = "a")
p <- ggplot(df, aes(x,y))+geom_point(aes(colour=z))
p + labs(x="X axis", y="Y axis", colour="Colour\nlegend")
#여기서 colour는 실제 색을 바꾸는게 아니라 색 구분하는 legend부분의 이름을 바꿔주는 것!


ggplot(diamonds, aes(price, color=cut))+
  geom_freqpoly(binwidth=500) +
  ggtitle("TITLE")

#축 이름 지정하지 않는 방법 두 가지

p + labs(x="", y="")
#-> ""로 지정 -> 칸은 만들되 아무것도 적지 말아라

p+labs(x=NULL, y=NULL)
# -> 아예 x축이랑 y축 칸을 없애라.


df <- data.frame(x=1:2, y=1, z="a")
p <- ggplot(df, aes(x,y))+geom_point()

#plot 가장자리(background)에 rectangle 만들기
p+theme(plot.background = element_rect(color="red"))


##Breaks and labels
df <- data.frame(x=c(1,3,5)*1000, y=1)
axs <- ggplot(df, aes(x,y))+geom_point()+labs(x=NULL, y=NULL)
axs

#x축 y축에 원하는 특정값만 scale로 나타내기
axs+scale_x_continuous(breaks=c(2000, 4000))
axs+scale_x_continuous(breaks=c(1000, 2000, 4000))

#2000, 4000대신 2k, 4k로 표현하기 -> label 설정
axs+scale_x_continuous(breaks=c(2000, 4000), labels=c("2k", "4k"))
#break에 들어가는건 실제 숫자를 체크하는 거고, label은 그 이름을 내맘대로 지정


#범주형
df2 <- data.frame(x=1:3, y=c("a", "b", "c"))
ggplot(df2, aes(x,y)) + geom_point()
ggplot(df2, aes(x,y)) + geom_point() +
  scale_y_discrete(labels=c(a="apple", b="banana", c="carrot"))


#legend
df <- data.frame(x=1, y=1:3, z=letters[1:3])
p <- ggplot(df, aes(x,y,colour=z))
p+geom_point()
p+geom_point()+geom_path()
#그룹을 지정 안해주면 색깔을 나눈 group인 z로 path도 grouping해서 그림.
#그런데 z로 grouping하면 이을 선이 없으므로 warning이 뜬다.

p+geom_point()+geom_path(aes(group=1))
#이렇게하면 point와 path에 대한 legend가 같이 나타남.
#모든 값이 1인 group이라는 변수를 만들고 이 그룹대로 이어주었다고 볼 수 있음.
p+geom_point()+geom_path(aes(group=c(1,1,2)))
#이렇게 하면 1,2번째는 group값이 1, 3번째는 group값이 3으로 지정되어서
#같은 그룹값을 가진 1,2번째 값이 이어진다.

p+geom_point()+geom_path(aes(group=1), show.legend=FALSE)
#path에 대한 legend는 ㄴ없어지고 점만 나옴.


p+geom_raster()
p+geom_raster(aes(fill=z))

ggplot(df, aes(x,y))+geom_point(size=4, color="grey20")
ggplot(df, aes(x,y))+geom_point(aes(color=z), size=2)

#위의 두개를 같이 그리기
ggplot(df, aes(x,y))+
  geom_point(size=4, color="grey20") +
  geom_point(aes(color=z), size=2)
#-> legend는 color에 따라 다른 점을 찍는 geom이 두번째 geom이므로 두번째에 맞춰 설정됨.
#첫번째 geom은 그냥 점찍는것과 다름없음.

#두 point를 모두 legend로 표시할 경우.
ggplot(df, aes(x,y))+
  geom_point(size=4, color="grey20", show.legend = TRUE) +
  geom_point(aes(color=z), size=2)

ggplot(df, aes(x,y))+
  geom_point(size=4, color="grey20", show.legend=TRUE) +
  geom_point(aes(color=z), size=2, show.legend=FALSE)
#이 경우 color로 grouping 되어있긴 하기 때문에 legend에서 구분은 됨.
